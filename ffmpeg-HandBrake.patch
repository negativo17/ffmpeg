diff -Naur ffmpeg-7.0.2.old/libavcodec/amfenc.c ffmpeg-7.0.2/libavcodec/amfenc.c
--- ffmpeg-7.0.2.old/libavcodec/amfenc.c	2024-08-29 08:36:42.196107206 +0200
+++ ffmpeg-7.0.2/libavcodec/amfenc.c	2024-08-29 08:36:43.650122216 +0200
@@ -36,6 +36,55 @@
 #include "amfenc.h"
 #include "encode.h"
 #include "internal.h"
+#include "libavutil/mastering_display_metadata.h"
+
+static int amf_save_hdr_metadata(AVCodecContext *avctx, const AVFrame *frame, AMFHDRMetadata *hdrmeta)
+{
+    AVFrameSideData            *sd_display;
+    AVFrameSideData            *sd_light;
+    AVMasteringDisplayMetadata *display_meta;
+    AVContentLightMetadata     *light_meta;
+    sd_display = av_frame_get_side_data(frame, AV_FRAME_DATA_MASTERING_DISPLAY_METADATA);
+    if (sd_display) {
+        display_meta = (AVMasteringDisplayMetadata *)sd_display->data;
+        if (display_meta->has_luminance) {
+            const unsigned int luma_den = 10000;
+            hdrmeta->maxMasteringLuminance =
+                (amf_uint32)(luma_den * av_q2d(display_meta->max_luminance));
+            hdrmeta->minMasteringLuminance =
+                FFMIN((amf_uint32)(luma_den * av_q2d(display_meta->min_luminance)), hdrmeta->maxMasteringLuminance);
+        }
+        if (display_meta->has_primaries) {
+            const unsigned int chroma_den = 50000;
+            hdrmeta->redPrimary[0] =
+                FFMIN((amf_uint16)(chroma_den * av_q2d(display_meta->display_primaries[0][0])), chroma_den);
+            hdrmeta->redPrimary[1] =
+                FFMIN((amf_uint16)(chroma_den * av_q2d(display_meta->display_primaries[0][1])), chroma_den);
+            hdrmeta->greenPrimary[0] =
+                FFMIN((amf_uint16)(chroma_den * av_q2d(display_meta->display_primaries[1][0])), chroma_den);
+            hdrmeta->greenPrimary[1] =
+                FFMIN((amf_uint16)(chroma_den * av_q2d(display_meta->display_primaries[1][1])), chroma_den);
+            hdrmeta->bluePrimary[0] =
+                FFMIN((amf_uint16)(chroma_den * av_q2d(display_meta->display_primaries[2][0])), chroma_den);
+            hdrmeta->bluePrimary[1] =
+                FFMIN((amf_uint16)(chroma_den * av_q2d(display_meta->display_primaries[2][1])), chroma_den);
+            hdrmeta->whitePoint[0] =
+                FFMIN((amf_uint16)(chroma_den * av_q2d(display_meta->white_point[0])), chroma_den);
+            hdrmeta->whitePoint[1] =
+                FFMIN((amf_uint16)(chroma_den * av_q2d(display_meta->white_point[1])), chroma_den);
+        }
+        sd_light = av_frame_get_side_data(frame, AV_FRAME_DATA_CONTENT_LIGHT_LEVEL);
+        if (sd_light) {
+            light_meta = (AVContentLightMetadata *)sd_light->data;
+            if (light_meta) {
+                hdrmeta->maxContentLightLevel = (amf_uint16)light_meta->MaxCLL;
+                hdrmeta->maxFrameAverageLightLevel = (amf_uint16)light_meta->MaxFALL;
+            }
+        }
+        return 0;
+    }
+    return 1;
+}
 
 #if CONFIG_D3D11VA
 #include <d3d11.h>
@@ -60,6 +109,7 @@
 #if CONFIG_DXVA2
     AV_PIX_FMT_DXVA2_VLD,
 #endif
+    AV_PIX_FMT_P010,
     AV_PIX_FMT_NONE
 };
 
@@ -72,6 +122,7 @@
 {
     { AV_PIX_FMT_NONE,       AMF_SURFACE_UNKNOWN },
     { AV_PIX_FMT_NV12,       AMF_SURFACE_NV12 },
+    { AV_PIX_FMT_P010,       AMF_SURFACE_P010 },
     { AV_PIX_FMT_BGR0,       AMF_SURFACE_BGRA },
     { AV_PIX_FMT_RGB0,       AMF_SURFACE_RGBA },
     { AV_PIX_FMT_GRAY8,      AMF_SURFACE_GRAY8 },
@@ -681,6 +732,26 @@
             frame_ref_storage_buffer->pVtbl->Release(frame_ref_storage_buffer);
         }
 
+        // HDR10 metadata
+        if (frame->color_trc == AVCOL_TRC_SMPTE2084) {
+            AMFBuffer * hdrmeta_buffer = NULL;
+            res = ctx->context->pVtbl->AllocBuffer(ctx->context, AMF_MEMORY_HOST, sizeof(AMFHDRMetadata), &hdrmeta_buffer);
+            if (res == AMF_OK) {
+                AMFHDRMetadata * hdrmeta = (AMFHDRMetadata*)hdrmeta_buffer->pVtbl->GetNative(hdrmeta_buffer);
+                if (amf_save_hdr_metadata(avctx, frame, hdrmeta) == 0) {
+                    switch (avctx->codec->id) {
+                    case AV_CODEC_ID_H264:
+                        AMF_ASSIGN_PROPERTY_INTERFACE(res, ctx->encoder, AMF_VIDEO_ENCODER_INPUT_HDR_METADATA, hdrmeta_buffer); break;
+                    case AV_CODEC_ID_HEVC:
+                        AMF_ASSIGN_PROPERTY_INTERFACE(res, ctx->encoder, AMF_VIDEO_ENCODER_HEVC_INPUT_HDR_METADATA, hdrmeta_buffer); break;
+                    }
+                    res = amf_set_property_buffer(surface, L"av_frame_hdrmeta", hdrmeta_buffer);
+                    AMF_RETURN_IF_FALSE(avctx, res == AMF_OK, AVERROR_UNKNOWN, "SetProperty failed for \"av_frame_hdrmeta\" with error %d\n", res);
+                }
+                hdrmeta_buffer->pVtbl->Release(hdrmeta_buffer);
+            }
+        }
+
         surface->pVtbl->SetPts(surface, frame->pts);
         AMF_ASSIGN_PROPERTY_INT64(res, surface, PTS_PROP, frame->pts);
 
@@ -696,6 +767,53 @@
             break;
         }
 
+        // Override Picture Type for Frame
+        if (avctx->codec->id == AV_CODEC_ID_H264) {
+            switch (frame->pict_type) {
+            case AV_PICTURE_TYPE_I:
+                AMF_ASSIGN_PROPERTY_INT64(res, surface, AMF_VIDEO_ENCODER_FORCE_PICTURE_TYPE, AMF_VIDEO_ENCODER_PICTURE_TYPE_I);
+                break;
+            case AV_PICTURE_TYPE_P:
+                AMF_ASSIGN_PROPERTY_INT64(res, surface, AMF_VIDEO_ENCODER_FORCE_PICTURE_TYPE, AMF_VIDEO_ENCODER_PICTURE_TYPE_P);
+                break;
+            case AV_PICTURE_TYPE_B:
+                AMF_ASSIGN_PROPERTY_INT64(res, surface, AMF_VIDEO_ENCODER_FORCE_PICTURE_TYPE, AMF_VIDEO_ENCODER_PICTURE_TYPE_B);
+                break;
+            case AV_PICTURE_TYPE_S:
+                AMF_ASSIGN_PROPERTY_INT64(res, surface, AMF_VIDEO_ENCODER_FORCE_PICTURE_TYPE, AMF_VIDEO_ENCODER_PICTURE_TYPE_SKIP);
+                break;
+            default:
+                AMF_ASSIGN_PROPERTY_INT64(res, surface, AMF_VIDEO_ENCODER_FORCE_PICTURE_TYPE, AMF_VIDEO_ENCODER_PICTURE_TYPE_NONE);
+                break;
+            }
+            // Keyframe overrides previous assignment.
+            if (frame->flags & AV_FRAME_FLAG_KEY) {
+                AMF_ASSIGN_PROPERTY_INT64(res, surface, AMF_VIDEO_ENCODER_FORCE_PICTURE_TYPE, AMF_VIDEO_ENCODER_PICTURE_TYPE_IDR);
+            }
+        } else if (avctx->codec->id == AV_CODEC_ID_HEVC) {
+            switch (frame->pict_type) {
+            case AV_PICTURE_TYPE_I:
+                AMF_ASSIGN_PROPERTY_INT64(res, surface, AMF_VIDEO_ENCODER_HEVC_FORCE_PICTURE_TYPE, AMF_VIDEO_ENCODER_HEVC_PICTURE_TYPE_I);
+                break;
+            case AV_PICTURE_TYPE_P:
+                AMF_ASSIGN_PROPERTY_INT64(res, surface, AMF_VIDEO_ENCODER_HEVC_FORCE_PICTURE_TYPE, AMF_VIDEO_ENCODER_HEVC_PICTURE_TYPE_P);
+                break;
+            case AV_PICTURE_TYPE_B:
+                av_log(ctx, AV_LOG_WARNING, "Ignoring B-Frame, unsupported by AMD AMF H.265 Encoder.");
+                break;
+            case AV_PICTURE_TYPE_S:
+                AMF_ASSIGN_PROPERTY_INT64(res, surface, AMF_VIDEO_ENCODER_HEVC_FORCE_PICTURE_TYPE, AMF_VIDEO_ENCODER_HEVC_PICTURE_TYPE_SKIP);
+                break;
+            default:
+                AMF_ASSIGN_PROPERTY_INT64(res, surface, AMF_VIDEO_ENCODER_HEVC_FORCE_PICTURE_TYPE, AMF_VIDEO_ENCODER_HEVC_PICTURE_TYPE_NONE);
+                break;
+            }
+            // Keyframe overrides previous assignment.
+            if (frame->flags & AV_FRAME_FLAG_KEY) {
+                AMF_ASSIGN_PROPERTY_INT64(res, surface, AMF_VIDEO_ENCODER_HEVC_FORCE_PICTURE_TYPE, AMF_VIDEO_ENCODER_HEVC_PICTURE_TYPE_IDR);
+            }
+        }
+
         // submit surface
         res = ctx->encoder->pVtbl->SubmitInput(ctx->encoder, (AMFData*)surface);
         if (res == AMF_INPUT_FULL) { // handle full queue
@@ -744,6 +862,19 @@
         }
         res_resubmit = AMF_OK;
         if (ctx->delayed_surface != NULL) { // try to resubmit frame
+            if (ctx->delayed_surface->pVtbl->HasProperty(ctx->delayed_surface, L"av_frame_hdrmeta")) {
+                AMFBuffer * hdrmeta_buffer = NULL;
+                res = amf_get_property_buffer((AMFData *)ctx->delayed_surface, L"av_frame_hdrmeta", &hdrmeta_buffer);
+                AMF_RETURN_IF_FALSE(avctx, res == AMF_OK, AVERROR_UNKNOWN, "GetProperty failed for \"av_frame_hdrmeta\" with error %d\n", res);
+                switch (avctx->codec->id) {
+                case AV_CODEC_ID_H264:
+                    AMF_ASSIGN_PROPERTY_INTERFACE(res, ctx->encoder, AMF_VIDEO_ENCODER_INPUT_HDR_METADATA, hdrmeta_buffer); break;
+                case AV_CODEC_ID_HEVC:
+                    AMF_ASSIGN_PROPERTY_INTERFACE(res, ctx->encoder, AMF_VIDEO_ENCODER_HEVC_INPUT_HDR_METADATA, hdrmeta_buffer); break;
+                }
+                hdrmeta_buffer->pVtbl->Release(hdrmeta_buffer);
+            }
+
             res_resubmit = ctx->encoder->pVtbl->SubmitInput(ctx->encoder, (AMFData*)ctx->delayed_surface);
             if (res_resubmit != AMF_INPUT_FULL) {
                 int64_t pts = ctx->delayed_surface->pVtbl->GetPts(ctx->delayed_surface);
diff -Naur ffmpeg-7.0.2.old/libavcodec/amfenc.h ffmpeg-7.0.2/libavcodec/amfenc.h
--- ffmpeg-7.0.2.old/libavcodec/amfenc.h	2024-08-29 08:36:42.150106731 +0200
+++ ffmpeg-7.0.2/libavcodec/amfenc.h	2024-08-29 08:36:43.648122195 +0200
@@ -21,6 +21,7 @@
 
 #include <AMF/core/Factory.h>
 
+#include <AMF/components/ColorSpace.h>
 #include <AMF/components/VideoEncoderVCE.h>
 #include <AMF/components/VideoEncoderHEVC.h>
 #include <AMF/components/VideoEncoderAV1.h>
diff -Naur ffmpeg-7.0.2.old/libavcodec/amfenc_h264.c ffmpeg-7.0.2/libavcodec/amfenc_h264.c
--- ffmpeg-7.0.2.old/libavcodec/amfenc_h264.c	2024-08-29 08:36:42.377109074 +0200
+++ ffmpeg-7.0.2/libavcodec/amfenc_h264.c	2024-08-29 08:36:43.648122195 +0200
@@ -199,6 +199,9 @@
     AMFRate                          framerate;
     AMFSize                          framesize = AMFConstructSize(avctx->width, avctx->height);
     int                              deblocking_filter = (avctx->flags & AV_CODEC_FLAG_LOOP_FILTER) ? 1 : 0;
+    amf_int64                        color_depth;
+    amf_int64                        color_profile;
+    enum                             AVPixelFormat pix_fmt;
 
     if (avctx->framerate.num > 0 && avctx->framerate.den > 0) {
         framerate = AMFConstructRate(avctx->framerate.num, avctx->framerate.den);
@@ -262,10 +265,51 @@
         AMF_ASSIGN_PROPERTY_RATIO(res, ctx->encoder, AMF_VIDEO_ENCODER_ASPECT_RATIO, ratio);
     }
 
-    /// Color Range (Partial/TV/MPEG or Full/PC/JPEG)
+    // Color Metadata
+    /// Color Range (Support for older Drivers)
     if (avctx->color_range == AVCOL_RANGE_JPEG) {
         AMF_ASSIGN_PROPERTY_BOOL(res, ctx->encoder, AMF_VIDEO_ENCODER_FULL_RANGE_COLOR, 1);
+    } else {
+        AMF_ASSIGN_PROPERTY_BOOL(res, ctx->encoder, AMF_VIDEO_ENCODER_FULL_RANGE_COLOR, 0);
+    }
+    /// Color Space & Depth
+    pix_fmt = avctx->hw_frames_ctx ? ((AVHWFramesContext*)avctx->hw_frames_ctx->data)->sw_format
+                                : avctx->pix_fmt;
+    color_depth = AMF_COLOR_BIT_DEPTH_8;
+    if (pix_fmt == AV_PIX_FMT_P010) {
+        color_depth = AMF_COLOR_BIT_DEPTH_10;
+    }
+    color_profile = AMF_VIDEO_CONVERTER_COLOR_PROFILE_UNKNOWN;
+    switch (avctx->colorspace) {
+    case AVCOL_SPC_SMPTE170M:
+        if (avctx->color_range == AVCOL_RANGE_JPEG) {
+            color_profile = AMF_VIDEO_CONVERTER_COLOR_PROFILE_FULL_601;
+        } else {
+            color_profile = AMF_VIDEO_CONVERTER_COLOR_PROFILE_601;
+        }
+        break;
+    case AVCOL_SPC_BT709:
+        if (avctx->color_range == AVCOL_RANGE_JPEG) {
+            color_profile = AMF_VIDEO_CONVERTER_COLOR_PROFILE_FULL_709;
+        } else {
+            color_profile = AMF_VIDEO_CONVERTER_COLOR_PROFILE_709;
+        }
+        break;
+    case AVCOL_SPC_BT2020_NCL:
+    case AVCOL_SPC_BT2020_CL:
+        if (avctx->color_range == AVCOL_RANGE_JPEG) {
+            color_profile = AMF_VIDEO_CONVERTER_COLOR_PROFILE_FULL_2020;
+        } else {
+            color_profile = AMF_VIDEO_CONVERTER_COLOR_PROFILE_2020;
+        }
+        break;
     }
+    AMF_ASSIGN_PROPERTY_INT64(res, ctx->encoder, AMF_VIDEO_ENCODER_COLOR_BIT_DEPTH, color_depth);
+    AMF_ASSIGN_PROPERTY_INT64(res, ctx->encoder, AMF_VIDEO_ENCODER_OUTPUT_COLOR_PROFILE, color_profile);
+    /// Color Transfer Characteristics (AMF matches ISO/IEC)
+    AMF_ASSIGN_PROPERTY_INT64(res, ctx->encoder, AMF_VIDEO_ENCODER_OUTPUT_TRANSFER_CHARACTERISTIC, (amf_int64)avctx->color_trc);
+    /// Color Primaries (AMF matches ISO/IEC)
+    AMF_ASSIGN_PROPERTY_INT64(res, ctx->encoder, AMF_VIDEO_ENCODER_OUTPUT_COLOR_PRIMARIES, (amf_int64)avctx->color_primaries);
 
     // autodetect rate control method
     if (ctx->rate_control_mode == AMF_VIDEO_ENCODER_RATE_CONTROL_METHOD_UNKNOWN) {
diff -Naur ffmpeg-7.0.2.old/libavcodec/amfenc_hevc.c ffmpeg-7.0.2/libavcodec/amfenc_hevc.c
--- ffmpeg-7.0.2.old/libavcodec/amfenc_hevc.c	2024-08-29 08:36:42.151106741 +0200
+++ ffmpeg-7.0.2/libavcodec/amfenc_hevc.c	2024-08-29 08:36:43.648122195 +0200
@@ -34,8 +34,9 @@
     { "high_quality",           "high quality trancoding",                  0, AV_OPT_TYPE_CONST, {.i64 = AMF_VIDEO_ENCODER_HEVC_USAGE_HIGH_QUALITY              }, 0, 0, VE, .unit = "usage" },
     { "lowlatency_high_quality","low latency yet high quality trancoding",  0, AV_OPT_TYPE_CONST, {.i64 = AMF_VIDEO_ENCODER_HEVC_USAGE_LOW_LATENCY_HIGH_QUALITY  }, 0, 0, VE, .unit = "usage" },
 
-    { "profile",        "Set the profile (default main)",           OFFSET(profile),   AV_OPT_TYPE_INT,{ .i64 = AMF_VIDEO_ENCODER_HEVC_PROFILE_MAIN }, AMF_VIDEO_ENCODER_HEVC_PROFILE_MAIN, AMF_VIDEO_ENCODER_HEVC_PROFILE_MAIN, VE, .unit = "profile" },
-    { "main",           "", 0,                      AV_OPT_TYPE_CONST,{ .i64 = AMF_VIDEO_ENCODER_HEVC_PROFILE_MAIN }, 0, 0, VE, .unit = "profile" },
+    { "profile",        "Set the profile (default main)",           OFFSET(profile),   AV_OPT_TYPE_INT,{ .i64 = AMF_VIDEO_ENCODER_HEVC_PROFILE_MAIN }, AMF_VIDEO_ENCODER_HEVC_PROFILE_MAIN, AMF_VIDEO_ENCODER_HEVC_PROFILE_MAIN_10, VE, "profile" },
+    { "main",           "", 0,                      AV_OPT_TYPE_CONST,{ .i64 = AMF_VIDEO_ENCODER_HEVC_PROFILE_MAIN }, AMF_VIDEO_ENCODER_HEVC_PROFILE_MAIN, AMF_VIDEO_ENCODER_HEVC_PROFILE_MAIN_10, VE, "profile" },
+    { "main10",         "", 0,                      AV_OPT_TYPE_CONST,{ .i64 = AMF_VIDEO_ENCODER_HEVC_PROFILE_MAIN_10 }, 0, 0, VE, "profile" },
 
     { "profile_tier",   "Set the profile tier (default main)",      OFFSET(tier), AV_OPT_TYPE_INT,{ .i64 = AMF_VIDEO_ENCODER_HEVC_TIER_MAIN }, AMF_VIDEO_ENCODER_HEVC_TIER_MAIN, AMF_VIDEO_ENCODER_HEVC_TIER_HIGH, VE, .unit = "tier" },
     { "main",           "", 0, AV_OPT_TYPE_CONST, { .i64 = AMF_VIDEO_ENCODER_HEVC_TIER_MAIN }, 0, 0, VE, .unit = "tier" },
@@ -160,6 +161,9 @@
     AMFRate             framerate;
     AMFSize             framesize = AMFConstructSize(avctx->width, avctx->height);
     int                 deblocking_filter = (avctx->flags & AV_CODEC_FLAG_LOOP_FILTER) ? 1 : 0;
+    amf_int64           color_depth;
+    amf_int64           color_profile;
+    enum                AVPixelFormat pix_fmt;
 
     if (avctx->framerate.num > 0 && avctx->framerate.den > 0) {
         framerate = AMFConstructRate(avctx->framerate.num, avctx->framerate.den);
@@ -183,10 +187,14 @@
 
     AMF_ASSIGN_PROPERTY_RATE(res, ctx->encoder, AMF_VIDEO_ENCODER_HEVC_FRAMERATE, framerate);
 
+    color_depth = AMF_COLOR_BIT_DEPTH_8;
     switch (avctx->profile) {
     case AV_PROFILE_HEVC_MAIN:
         profile = AMF_VIDEO_ENCODER_HEVC_PROFILE_MAIN;
         break;
+    case AV_PROFILE_HEVC_MAIN_10:
+        profile = AMF_VIDEO_ENCODER_HEVC_PROFILE_MAIN_10;
+        break;
     default:
         break;
     }
@@ -215,6 +223,51 @@
         AMF_ASSIGN_PROPERTY_RATIO(res, ctx->encoder, AMF_VIDEO_ENCODER_HEVC_ASPECT_RATIO, ratio);
     }
 
+    // Color Metadata
+    /// Color Range (Support for older Drivers)
+    if (avctx->color_range == AVCOL_RANGE_JPEG) {
+        AMF_ASSIGN_PROPERTY_BOOL(res, ctx->encoder, AMF_VIDEO_ENCODER_HEVC_NOMINAL_RANGE, 1);
+    } else {
+        AMF_ASSIGN_PROPERTY_BOOL(res, ctx->encoder, AMF_VIDEO_ENCODER_HEVC_NOMINAL_RANGE, 0);
+    }
+    /// Color Space & Depth
+    pix_fmt = avctx->hw_frames_ctx ? ((AVHWFramesContext*)avctx->hw_frames_ctx->data)->sw_format
+                                : avctx->pix_fmt;
+    if (pix_fmt == AV_PIX_FMT_P010) {
+        color_depth = AMF_COLOR_BIT_DEPTH_10;
+    }
+    color_profile = AMF_VIDEO_CONVERTER_COLOR_PROFILE_UNKNOWN;
+    switch (avctx->colorspace) {
+        case AVCOL_SPC_SMPTE170M:
+            if (avctx->color_range == AVCOL_RANGE_JPEG) {
+                color_profile = AMF_VIDEO_CONVERTER_COLOR_PROFILE_FULL_601;
+            } else {
+                color_profile = AMF_VIDEO_CONVERTER_COLOR_PROFILE_601;
+            }
+            break;
+        case AVCOL_SPC_BT709:
+            if (avctx->color_range == AVCOL_RANGE_JPEG) {
+                color_profile = AMF_VIDEO_CONVERTER_COLOR_PROFILE_FULL_709;
+            } else {
+                color_profile = AMF_VIDEO_CONVERTER_COLOR_PROFILE_709;
+            }
+            break;
+        case AVCOL_SPC_BT2020_NCL:
+        case AVCOL_SPC_BT2020_CL:
+            if (avctx->color_range == AVCOL_RANGE_JPEG) {
+                color_profile = AMF_VIDEO_CONVERTER_COLOR_PROFILE_FULL_2020;
+            } else {
+                color_profile = AMF_VIDEO_CONVERTER_COLOR_PROFILE_2020;
+            }
+            break;
+    }
+    AMF_ASSIGN_PROPERTY_INT64(res, ctx->encoder, AMF_VIDEO_ENCODER_HEVC_COLOR_BIT_DEPTH, color_depth);
+    AMF_ASSIGN_PROPERTY_INT64(res, ctx->encoder, AMF_VIDEO_ENCODER_HEVC_OUTPUT_COLOR_PROFILE, color_profile);
+    /// Color Transfer Characteristics (AMF matches ISO/IEC)
+    AMF_ASSIGN_PROPERTY_INT64(res, ctx->encoder, AMF_VIDEO_ENCODER_HEVC_OUTPUT_TRANSFER_CHARACTERISTIC, (amf_int64)avctx->color_trc);
+    /// Color Primaries (AMF matches ISO/IEC)
+    AMF_ASSIGN_PROPERTY_INT64(res, ctx->encoder, AMF_VIDEO_ENCODER_HEVC_OUTPUT_COLOR_PRIMARIES, (amf_int64)avctx->color_primaries);
+
     // Picture control properties
     AMF_ASSIGN_PROPERTY_INT64(res, ctx->encoder, AMF_VIDEO_ENCODER_HEVC_NUM_GOPS_PER_IDR, ctx->gops_per_idr);
     AMF_ASSIGN_PROPERTY_INT64(res, ctx->encoder, AMF_VIDEO_ENCODER_HEVC_GOP_SIZE, avctx->gop_size);
diff -Naur ffmpeg-7.0.2.old/libavcodec/av1dec.c ffmpeg-7.0.2/libavcodec/av1dec.c
--- ffmpeg-7.0.2.old/libavcodec/av1dec.c	2024-08-29 08:36:42.266107928 +0200
+++ ffmpeg-7.0.2/libavcodec/av1dec.c	2024-08-29 08:36:43.651122226 +0200
@@ -1028,6 +1028,8 @@
         break;
     }
     case ITU_T_T35_PROVIDER_CODE_DOLBY: {
+        AVBufferRef *rpu_buf;
+        AVFrameSideData *rpu;
         int provider_oriented_code = bytestream2_get_be32(&gb);
         if (itut_t35->itu_t_t35_country_code != ITU_T_T35_COUNTRY_CODE_US ||
             provider_oriented_code != 0x800)
@@ -1039,6 +1041,18 @@
             break; // ignore
         }
 
+        rpu_buf = av_buffer_alloc(itut_t35->payload_size);
+        if (rpu_buf) {
+            memcpy(rpu_buf->data, itut_t35->payload, itut_t35->payload_size);
+            rpu = av_frame_new_side_data_from_buf(frame, AV_FRAME_DATA_DOVI_RPU_BUFFER_T35, rpu_buf);
+            if (!rpu) {
+                av_buffer_unref(&rpu_buf);
+                return AVERROR(ENOMEM);
+            }
+        } else {
+            return AVERROR(ENOMEM);
+        }
+
         ret = ff_dovi_attach_side_data(&s->dovi, frame);
         if (ret < 0)
             return ret;
diff -Naur ffmpeg-7.0.2.old/libavcodec/bsf/hevc_mp4toannexb.c ffmpeg-7.0.2/libavcodec/bsf/hevc_mp4toannexb.c
--- ffmpeg-7.0.2.old/libavcodec/bsf/hevc_mp4toannexb.c	2024-08-29 08:36:42.242107680 +0200
+++ ffmpeg-7.0.2/libavcodec/bsf/hevc_mp4toannexb.c	2024-08-29 08:36:43.646122174 +0200
@@ -124,6 +124,7 @@
     AVPacket *in;
     GetByteContext gb;
 
+    int has_sps = 0, has_pps = 0;
     int got_irap = 0;
     int i, ret = 0;
 
@@ -157,11 +158,14 @@
         }
 
         nalu_type = (bytestream2_peek_byte(&gb) >> 1) & 0x3f;
+        has_sps = (has_sps || nalu_type == HEVC_NAL_SPS);
+        has_pps = (has_pps || nalu_type == HEVC_NAL_PPS);
 
         /* prepend extradata to IRAP frames */
         is_irap = nalu_type >= HEVC_NAL_BLA_W_LP &&
                   nalu_type <= HEVC_NAL_RSV_IRAP_VCL23;
-        add_extradata = is_irap && !got_irap;
+        /* ignore the extradata if IRAP frame has sps and pps */
+        add_extradata = is_irap && !got_irap && !(has_sps && has_pps);
         extra_size    = add_extradata * ctx->par_out->extradata_size;
         got_irap     |= is_irap;
 
diff -Naur ffmpeg-7.0.2.old/libavcodec/ccaption_dec.c ffmpeg-7.0.2/libavcodec/ccaption_dec.c
--- ffmpeg-7.0.2.old/libavcodec/ccaption_dec.c	2024-08-29 08:36:42.368108981 +0200
+++ ffmpeg-7.0.2/libavcodec/ccaption_dec.c	2024-08-29 08:36:43.641122123 +0200
@@ -889,12 +889,13 @@
 
         if (ctx->buffer[bidx].str[0] || ctx->real_time) {
             ff_dlog(ctx, "cdp writing data (%s)\n", ctx->buffer[bidx].str);
-            start_time = ctx->buffer_time[0];
-            sub->pts = start_time;
-            end_time = ctx->buffer_time[1];
-            if (!ctx->real_time)
+            if (!ctx->real_time) {
+                start_time = ctx->buffer_time[0];
+                sub->pts = start_time;
+                end_time = ctx->buffer_time[1];
                 sub->end_display_time = av_rescale_q(end_time - start_time,
                                                      AV_TIME_BASE_Q, ms_tb);
+            }
             else
                 sub->end_display_time = -1;
             ret = ff_ass_add_rect2(sub, ctx->buffer[bidx].str, ctx->readorder++, 0, NULL, NULL, &nb_rect_allocated);
diff -Naur ffmpeg-7.0.2.old/libavcodec/dvdsubdec.c ffmpeg-7.0.2/libavcodec/dvdsubdec.c
--- ffmpeg-7.0.2.old/libavcodec/dvdsubdec.c	2024-08-29 08:36:42.135106576 +0200
+++ ffmpeg-7.0.2/libavcodec/dvdsubdec.c	2024-08-29 08:36:43.640122113 +0200
@@ -44,6 +44,8 @@
   int      buf_size;
   int      forced_subs_only;
   uint8_t  used_color[256];
+  int64_t  pts;
+  int      output_empty_rects;
 } DVDSubContext;
 
 static void yuv_a_to_rgba(const uint8_t *ycbcr, const uint8_t *alpha, uint32_t *rgba, int num_values)
@@ -229,7 +231,10 @@
     uint32_t size;
     int64_t offset1, offset2;
 
-    if (buf_size < 10)
+    if (buf_size < 2)
+        return AVERROR(EAGAIN);
+
+    if (buf_size == 2 && AV_RB16(buf) == 0)
         return -1;
 
     if (AV_RB16(buf) == 0) {   /* HD subpicture with 4-byte offsets */
@@ -242,15 +247,22 @@
         cmd_pos = 2;
     }
 
+    if (big_offsets && buf_size < 6)
+        return AVERROR(EAGAIN);
+
     size = READ_OFFSET(buf + (big_offsets ? 2 : 0));
-    cmd_pos = READ_OFFSET(buf + cmd_pos);
 
-    if (cmd_pos < 0 || cmd_pos > buf_size - 2 - offset_size) {
-        if (cmd_pos > size) {
-            av_log(ctx, AV_LOG_ERROR, "Discarding invalid packet\n");
-            return 0;
-        }
+    if (size == 0)
+        return -1;
+
+    if (buf_size < size)
         return AVERROR(EAGAIN);
+
+    cmd_pos = READ_OFFSET(buf + cmd_pos);
+
+    if (cmd_pos < 0 || cmd_pos > size) {
+        av_log(ctx, AV_LOG_ERROR, "Discarding invalid packet\n");
+        return AVERROR_INVALIDDATA;
     }
 
     while (cmd_pos > 0 && cmd_pos < buf_size - 2 - offset_size) {
@@ -523,10 +535,13 @@
     int appended = 0;
     int is_menu;
 
+    if (ctx->pts == AV_NOPTS_VALUE && sub->pts != AV_NOPTS_VALUE)
+        ctx->pts = sub->pts;
     if (ctx->buf_size) {
         int ret = append_to_cached_buf(avctx, buf, buf_size);
         if (ret < 0) {
             *data_size = 0;
+            ctx->pts = AV_NOPTS_VALUE;
             return ret;
         }
         buf = ctx->buf;
@@ -537,7 +552,12 @@
     is_menu = decode_dvd_subtitles(ctx, sub, buf, buf_size);
     if (is_menu == AVERROR(EAGAIN)) {
         *data_size = 0;
-        return appended ? 0 : append_to_cached_buf(avctx, buf, buf_size);
+        int ret = appended ? 0 : append_to_cached_buf(avctx, buf, buf_size);
+        if (ret < 0) {
+            ctx->pts = AV_NOPTS_VALUE;
+            return ret;
+        }
+        return buf_size;
     }
 
     if (is_menu < 0) {
@@ -546,9 +566,10 @@
         reset_rects(sub);
         *data_size = 0;
 
+        ctx->pts = AV_NOPTS_VALUE;
         return buf_size;
     }
-    if (!is_menu && find_smallest_bounding_rectangle(ctx, sub) == 0)
+    if (!is_menu && !ctx->output_empty_rects && find_smallest_bounding_rectangle(ctx, sub) == 0)
         goto no_subtitle;
 
     if (ctx->forced_subs_only && !(sub->rects[0]->flags & AV_SUBTITLE_FLAG_FORCED))
@@ -556,6 +577,8 @@
 
     ctx->buf_size = 0;
     *data_size = 1;
+    sub->pts = ctx->pts;
+    ctx->pts = AV_NOPTS_VALUE;
     return buf_size;
 }
 
@@ -681,6 +704,7 @@
             av_log(avctx, AV_LOG_DEBUG, " 0x%06"PRIx32, ctx->palette[i]);
         av_log(avctx, AV_LOG_DEBUG, "\n");
     }
+    ctx->pts = AV_NOPTS_VALUE;
 
     return 1;
 }
@@ -697,6 +721,7 @@
     { "palette", "set the global palette", OFFSET(palette_str), AV_OPT_TYPE_STRING, { .str = NULL }, 0, 0, SD },
     { "ifo_palette", "obtain the global palette from .IFO file", OFFSET(ifo_str), AV_OPT_TYPE_STRING, { .str = NULL }, 0, 0, SD },
     { "forced_subs_only", "Only show forced subtitles", OFFSET(forced_subs_only), AV_OPT_TYPE_BOOL, {.i64 = 0}, 0, 1, SD},
+    { "output_empty_rects", "Output subtitles with empty or fully transparent rects", OFFSET(output_empty_rects), AV_OPT_TYPE_BOOL, {.i64 = 0}, 0, 1, SD},
     { NULL }
 };
 static const AVClass dvdsub_class = {
diff -Naur ffmpeg-7.0.2.old/libavcodec/libdav1d.c ffmpeg-7.0.2/libavcodec/libdav1d.c
--- ffmpeg-7.0.2.old/libavcodec/libdav1d.c	2024-08-29 08:36:42.261107877 +0200
+++ ffmpeg-7.0.2/libavcodec/libdav1d.c	2024-08-29 08:36:43.651122226 +0200
@@ -562,6 +562,8 @@
             break;
         }
         case ITU_T_T35_PROVIDER_CODE_DOLBY: {
+            AVBufferRef *rpu_buf;
+            AVFrameSideData *rpu;
             int provider_oriented_code = bytestream2_get_be32(&gb);
             if (itut_t35->country_code != ITU_T_T35_COUNTRY_CODE_US ||
                 provider_oriented_code != 0x800)
@@ -573,6 +575,18 @@
                 break; // ignore
             }
 
+            rpu_buf = av_buffer_alloc(itut_t35->payload_size);
+            if (rpu_buf) {
+                memcpy(rpu_buf->data, itut_t35->payload, itut_t35->payload_size);
+                rpu = av_frame_new_side_data_from_buf(frame, AV_FRAME_DATA_DOVI_RPU_BUFFER_T35, rpu_buf);
+                if (!rpu) {
+                    av_buffer_unref(&rpu_buf);
+                    goto fail;
+                }
+            } else {
+                goto fail;
+            }
+
             res = ff_dovi_attach_side_data(&dav1d->dovi, frame);
             if (res < 0)
                 goto fail;
diff -Naur ffmpeg-7.0.2.old/libavcodec/videotoolbox.c ffmpeg-7.0.2/libavcodec/videotoolbox.c
--- ffmpeg-7.0.2.old/libavcodec/videotoolbox.c	2024-08-29 08:36:42.192107164 +0200
+++ ffmpeg-7.0.2/libavcodec/videotoolbox.c	2024-08-29 08:36:43.644122154 +0200
@@ -915,6 +915,23 @@
         break;
     }
 
+#if ARCH_X86_64
+    if (avctx->codec_id == AV_CODEC_ID_H264 &&
+        avctx->sw_pix_fmt == AV_PIX_FMT_YUV420P10)
+    {
+        // 10-bit H.264 is not supported on x86_64
+        return AVERROR(ENOSYS);
+    }
+#endif
+
+    if (avctx->codec_id == AV_CODEC_ID_H264 &&
+        (avctx->level == 61 || avctx->level == 62))
+    {
+        // H.264 Level 6.1 and 6.2 can't be
+        // decoded properly
+        return AVERROR(ENOSYS);
+    }
+
 #if defined(MAC_OS_X_VERSION_10_9) && !TARGET_OS_IPHONE && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_9) && AV_HAS_BUILTIN(__builtin_available)
     if (avctx->codec_id == AV_CODEC_ID_PRORES) {
         if (__builtin_available(macOS 10.9, *)) {
diff -Naur ffmpeg-7.0.2.old/libavformat/isom.h ffmpeg-7.0.2/libavformat/isom.h
--- ffmpeg-7.0.2.old/libavformat/isom.h	2024-08-29 08:36:42.640111790 +0200
+++ ffmpeg-7.0.2/libavformat/isom.h	2024-08-29 08:36:43.654122257 +0200
@@ -266,6 +266,9 @@
         MOVEncryptionIndex *encryption_index;
     } cenc;
 
+    int has_fallback;   // Audio fallback track
+    int fallback;
+
     struct IAMFDemuxContext *iamf;
 } MOVStreamContext;
 
diff -Naur ffmpeg-7.0.2.old/libavformat/matroskaenc.c ffmpeg-7.0.2/libavformat/matroskaenc.c
--- ffmpeg-7.0.2.old/libavformat/matroskaenc.c	2024-08-29 08:36:42.678112181 +0200
+++ ffmpeg-7.0.2/libavformat/matroskaenc.c	2024-08-29 08:36:43.643122143 +0200
@@ -2895,6 +2895,16 @@
     case AV_CODEC_ID_AAC:
         if (side_data_size && mkv->track.bc) {
             int output_sample_rate = 0;
+            if (par->extradata && par->extradata_size) {
+                if (par->extradata_size != side_data_size ||
+                    memcmp(par->extradata, side_data, side_data_size)) {
+                    av_log(s, AV_LOG_ERROR, "Error, AAC extradata changed mid-stream.\n");
+                    return AVERROR(EINVAL);
+                } else {
+                    // Already written
+                    break;
+                }
+            }
             ret = get_aac_sample_rates(s, mkv, side_data, side_data_size,
                                        &track->sample_rate, &output_sample_rate);
             if (ret < 0)
diff -Naur ffmpeg-7.0.2.old/libavformat/mov.c ffmpeg-7.0.2/libavformat/mov.c
--- ffmpeg-7.0.2.old/libavformat/mov.c	2024-08-29 08:36:42.623111614 +0200
+++ ffmpeg-7.0.2/libavformat/mov.c	2024-08-29 08:36:43.654122257 +0200
@@ -55,6 +55,7 @@
 #include "libavcodec/mpegaudiodecheader.h"
 #include "libavcodec/mlp_parse.h"
 #include "avformat.h"
+#include "avlanguage.h"
 #include "internal.h"
 #include "avio_internal.h"
 #include "demux.h"
@@ -325,6 +326,73 @@
     return 0;
 }
 
+static int mov_read_3gp_udta_tag(MOVContext *c, AVIOContext *pb, MOVAtom atom)
+{
+    const char *key;
+    AVDictionary *metadata;
+    uint16_t langcode = 0;
+    char key2[32], language[4] = {0};
+    uint32_t str_size, version;
+    char *str;
+    if (atom.size < 6)
+        return AVERROR_INVALIDDATA;
+    switch (atom.type) {
+    case MKTAG( 'a','l','b','m'): key = "album"; break;
+    case MKTAG( 'a','u','t','h'): key = "author"; break;
+    case MKTAG( 'c','p','r','t'): key = "copyright"; break;
+    case MKTAG( 'd','s','c','p'): key = "comment"; break;
+    case MKTAG( 'g','n','r','e'): key = "genre"; break;
+    case MKTAG( 'p','e','r','f'): key = "artist"; break;
+    case MKTAG( 't','i','t','l'): key = "title"; break;
+    case MKTAG( 'y','r','r','c'): key = "date"; break;
+    default: return 0;
+    }
+    version = avio_rb32(pb); // version + flags
+    if (version != 0)
+        av_log(c->fc, AV_LOG_WARNING, "udta %s unknown version number: %u\n", str, version);
+    if (MKTAG( 'y','r','r','c') == atom.type) {
+        int year;
+        year = avio_rb16(pb);
+        str = av_asprintf("%d", year);
+        if (!str)
+            return AVERROR(ENOMEM);
+    } else {
+        int ret;
+        const char *tmp;
+        langcode = avio_rb16(pb);
+        ff_mov_lang_to_iso639(langcode, language);
+        tmp = ff_convert_lang_to(language, AV_LANG_ISO639_2_BIBL);
+        if (!tmp)
+           av_log(c->fc, AV_LOG_WARNING, "udta %s unknown language code: %u\n", str, langcode);
+        str_size = atom.size - 6;
+        if (str_size <= 0 || str_size >= INT_MAX/2)
+            return AVERROR_INVALIDDATA;
+        str = av_mallocz(str_size + 1);
+        if (!str)
+            return AVERROR(ENOMEM);
+        ret = ffio_read_size(pb, str, str_size);
+        if (ret < 0) {
+            av_free(str);
+            return ret;
+        }
+        str[str_size] = 0;
+    }
+    if (c->trak_index < 0) {
+        metadata = c->fc->metadata;
+        c->fc->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED;
+    }
+    else {
+        metadata = c->fc->streams[c->trak_index]->metadata;
+    }
+    av_dict_set(&metadata, key, str, 0);
+    if (*language && strcmp(language, "und")) {
+        snprintf(key2, sizeof(key2), "%s-%s", key, language);
+        av_dict_set(&metadata, key2, str, 0);
+    }
+    av_freep(&str);
+    return 0;
+}
+
 static int mov_read_udta_string(MOVContext *c, AVIOContext *pb, MOVAtom atom)
 {
     char tmp_key[AV_FOURCC_MAX_STRING_SIZE] = {0};
@@ -337,6 +405,7 @@
     int (*parse)(MOVContext*, AVIOContext*, unsigned, const char*) = NULL;
     int raw = 0;
     int num = 0;
+    AVDictionary *metadata;
 
     switch (atom.type) {
     case MKTAG( '@','P','R','M'): key = "premiere_version"; raw = 1; break;
@@ -350,15 +419,33 @@
     case MKTAG( 'c','a','t','g'): key = "category"; break;
     case MKTAG( 'c','p','i','l'): key = "compilation";
         parse = mov_metadata_int8_no_padding; break;
-    case MKTAG( 'c','p','r','t'): key = "copyright"; break;
+    case MKTAG( 'c','p','r','t'):
+        key = "copyright";
+        if (!c->itunes_metadata) {
+            int64_t pos = avio_tell(pb);
+            int ret = mov_read_3gp_udta_tag(c, pb, atom);
+            if (ret != AVERROR_INVALIDDATA)
+                return ret;
+            avio_seek(pb, pos, SEEK_SET);
+        }
+        break;
     case MKTAG( 'd','e','s','c'): key = "description"; break;
     case MKTAG( 'd','i','s','k'): key = "disc";
         parse = mov_metadata_track_or_disc_number; break;
     case MKTAG( 'e','g','i','d'): key = "episode_uid";
         parse = mov_metadata_int8_no_padding; break;
     case MKTAG( 'F','I','R','M'): key = "firmware"; raw = 1; break;
-    case MKTAG( 'g','n','r','e'): key = "genre";
-        parse = mov_metadata_gnre; break;
+    case MKTAG( 'g','n','r','e'):
+        key = "genre";
+        parse = mov_metadata_gnre;
+        if (!c->itunes_metadata) {
+            int64_t pos = avio_tell(pb);
+            int ret = mov_read_3gp_udta_tag(c, pb, atom);
+            if (ret != AVERROR_INVALIDDATA)
+                return ret;
+            avio_seek(pb, pos, SEEK_SET);
+        }
+        break;
     case MKTAG( 'h','d','v','d'): key = "hd_video";
         parse = mov_metadata_int8_no_padding; break;
     case MKTAG( 'H','M','M','T'):
@@ -369,6 +456,7 @@
         return mov_metadata_loci(c, pb, atom.size);
     case MKTAG( 'm','a','n','u'): key = "make"; break;
     case MKTAG( 'm','o','d','l'): key = "model"; break;
+    case MKTAG( 'n','a','m','e'): key = "title"; raw = 1; break;
     case MKTAG( 'p','c','s','t'): key = "podcast";
         parse = mov_metadata_int8_no_padding; break;
     case MKTAG( 'p','g','a','p'): key = "gapless_playback";
@@ -428,6 +516,15 @@
     case MKTAG(0xa9,'w','r','n'): key = "warning";   break;
     case MKTAG(0xa9,'w','r','t'): key = "composer";  break;
     case MKTAG(0xa9,'x','y','z'): key = "location";  break;
+    case MKTAG( 'a','l','b','m'):
+    case MKTAG( 'a','u','t','h'):
+    case MKTAG( 'd','s','c','p'):
+    case MKTAG( 'p','e','r','f'):
+    case MKTAG( 't','i','t','l'):
+    case MKTAG( 'y','r','r','c'):
+        if (!c->itunes_metadata) {
+            return mov_read_3gp_udta_tag(c, pb, atom);
+        }
     }
 retry:
     if (c->itunes_metadata && atom.size > 8) {
@@ -554,17 +651,23 @@
             }
             str[str_size] = 0;
         }
-        c->fc->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED;
-        av_dict_set(&c->fc->metadata, key, str, 0);
+        if (c->trak_index < 0) {
+            metadata = c->fc->metadata;
+            c->fc->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED;
+            if (!strcmp(key, "encoder")) {
+                int major, minor, micro;
+                if (sscanf(str, "HandBrake %d.%d.%d", &major, &minor, &micro) == 3) {
+                    c->handbrake_version = 1000000*major + 1000*minor + micro;
+                }
+            }
+        }
+        else {
+            metadata = c->fc->streams[c->trak_index]->metadata;
+        }
+        av_dict_set(&metadata, key, str, 0);
         if (*language && strcmp(language, "und")) {
             snprintf(key2, sizeof(key2), "%s-%s", key, language);
-            av_dict_set(&c->fc->metadata, key2, str, 0);
-        }
-        if (!strcmp(key, "encoder")) {
-            int major, minor, micro;
-            if (sscanf(str, "HandBrake %d.%d.%d", &major, &minor, &micro) == 3) {
-                c->handbrake_version = 1000000*major + 1000*minor + micro;
-            }
+            av_dict_set(&metadata, key2, str, 0);
         }
     }
 
@@ -8529,6 +8632,23 @@
     return ret;
 }
 
+static int mov_read_fall(MOVContext *c, AVIOContext *pb, MOVAtom atom)
+{
+    AVStream *st;
+    MOVStreamContext *sc;
+
+    if (c->fc->nb_streams < 1)
+        return 0;
+    st = c->fc->streams[c->fc->nb_streams-1];
+    sc = st->priv_data;
+
+    sc->fallback = avio_rb32(pb);
+    sc->has_fallback = 1;
+
+    return 0;
+}
+
+
 static const MOVParseTableEntry mov_default_parse_table[] = {
 { MKTAG('A','C','L','R'), mov_read_aclr },
 { MKTAG('A','P','R','G'), mov_read_avid },
@@ -8627,6 +8747,7 @@
 { MKTAG('v','p','c','C'), mov_read_vpcc },
 { MKTAG('m','d','c','v'), mov_read_mdcv },
 { MKTAG('c','l','l','i'), mov_read_clli },
+{ MKTAG('f','a','l','l'), mov_read_fall },
 { MKTAG('d','v','c','C'), mov_read_dvcc_dvvc },
 { MKTAG('d','v','v','C'), mov_read_dvcc_dvvc },
 { MKTAG('d','v','w','C'), mov_read_dvcc_dvvc },
@@ -9744,6 +9865,23 @@
             err = ff_replaygain_export(st, s->metadata);
             if (err < 0)
                 return err;
+            if (sc->has_fallback) {
+                for (j = 0; j < s->nb_streams; j++) {
+                    if (s->streams[j]->id == sc->fallback) {
+                        AVPacketSideData *sd;
+                        int *fallback;
+                        sd = av_packet_side_data_new(&st->codecpar->coded_side_data,
+                                 &st->codecpar->nb_coded_side_data,
+                                 AV_PKT_DATA_FALLBACK_TRACK,
+                                 sizeof(int), 0);
+                        if (!sd)
+                            return AVERROR(ENOMEM);
+                        fallback = (int*)sd->data;
+                        *fallback = j;
+                        break;
+                    }
+                }
+            }
             break;
         case AVMEDIA_TYPE_VIDEO:
             if (sc->display_matrix) {
diff -Naur ffmpeg-7.0.2.old/libavformat/movenc.c ffmpeg-7.0.2/libavformat/movenc.c
--- ffmpeg-7.0.2.old/libavformat/movenc.c	2024-08-29 08:36:42.659111985 +0200
+++ ffmpeg-7.0.2/libavformat/movenc.c	2024-08-29 08:36:43.635122061 +0200
@@ -28,6 +28,7 @@
 
 #include "movenc.h"
 #include "avformat.h"
+#include "avlanguage.h"
 #include "avio_internal.h"
 #include "dovi_isom.h"
 #include "riff.h"
@@ -3766,6 +3767,41 @@
     return len + 24;
 }
 
+static uint16_t language_code(const char *str)
+{
+    return (((str[0] - 0x60) & 0x1F) << 10) +
+           (((str[1] - 0x60) & 0x1F) <<  5) +
+           (( str[2] - 0x60) & 0x1F);
+}
+static int mov_write_3gp_udta_tag(AVIOContext *pb, AVDictionary *metadata,
+                                  const char *tag, const char *str)
+{
+    int64_t pos = avio_tell(pb);
+    AVDictionaryEntry *t = av_dict_get(metadata, str, NULL, 0);
+    if (!t || !utf8len(t->value))
+        return 0;
+    avio_wb32(pb, 0);   /* size */
+    ffio_wfourcc(pb, tag); /* type */
+    avio_wb32(pb, 0);   /* version + flags */
+    if (!strcmp(tag, "yrrc"))
+        avio_wb16(pb, atoi(t->value));
+    else {
+        int lang = 0, len;
+        len = strlen(t->key);
+        if (t->key[len - 4] == '-') {
+            lang = ff_mov_iso639_to_lang(&t->key[len - 3], 1);
+        }
+        if (!lang)
+            lang = ff_mov_iso639_to_lang("und", 1);
+        avio_wb16(pb, lang); /* language */
+        avio_write(pb, t->value, strlen(t->value) + 1); /* UTF8 string value */
+        if (!strcmp(tag, "albm") &&
+            (t = av_dict_get(metadata, "track", NULL, 0)))
+            avio_w8(pb, atoi(t->value));
+    }
+    return update_size(pb, pos);
+}
+
 static int mov_write_track_metadata(AVIOContext *pb, AVStream *st,
                                     const char *tag, const char *str)
 {
@@ -3840,8 +3876,23 @@
     if (ret < 0)
         return ret;
 
-    if (mov->mode & (MODE_MP4|MODE_MOV))
+    if (mov->mode & (MODE_MP4|MODE_MOV)) {
+        AVDictionaryEntry *t = NULL;
+        int und = 0;
+
         mov_write_track_metadata(pb_buf, st, "name", "title");
+        while ((t = av_dict_get(st->metadata, "title-", t, AV_DICT_IGNORE_SUFFIX))) {
+            int len = strlen(t->key);
+            if (len == 10 &&
+                ff_convert_lang_to(&t->key[len - 3], AV_LANG_ISO639_2_BIBL)) {
+                mov_write_3gp_udta_tag(pb_buf, st->metadata, "titl", t->key);
+                if (!strcmp("und", &t->key[len - 3]))
+                    und = 1;
+            }
+        }
+        if (!und)
+            mov_write_3gp_udta_tag(pb_buf, st->metadata, "titl", "title");
+    }
 
     if (mov->mode & MODE_MP4) {
         if ((ret = mov_write_track_kinds(pb_buf, st)) < 0)
@@ -4438,35 +4489,6 @@
     return 0;
 }
 
-static uint16_t language_code(const char *str)
-{
-    return (((str[0] - 0x60) & 0x1F) << 10) +
-           (((str[1] - 0x60) & 0x1F) <<  5) +
-           (( str[2] - 0x60) & 0x1F);
-}
-
-static int mov_write_3gp_udta_tag(AVIOContext *pb, AVFormatContext *s,
-                                  const char *tag, const char *str)
-{
-    int64_t pos = avio_tell(pb);
-    AVDictionaryEntry *t = av_dict_get(s->metadata, str, NULL, 0);
-    if (!t || !utf8len(t->value))
-        return 0;
-    avio_wb32(pb, 0);   /* size */
-    ffio_wfourcc(pb, tag); /* type */
-    avio_wb32(pb, 0);   /* version + flags */
-    if (!strcmp(tag, "yrrc"))
-        avio_wb16(pb, atoi(t->value));
-    else {
-        avio_wb16(pb, language_code("eng")); /* language */
-        avio_write(pb, t->value, strlen(t->value) + 1); /* UTF8 string value */
-        if (!strcmp(tag, "albm") &&
-            (t = av_dict_get(s->metadata, "track", NULL, 0)))
-            avio_w8(pb, atoi(t->value));
-    }
-    return update_size(pb, pos);
-}
-
 static int mov_write_chpl_tag(AVIOContext *pb, AVFormatContext *s)
 {
     int64_t pos = avio_tell(pb);
@@ -4505,14 +4527,14 @@
         return ret;
 
     if (mov->mode & MODE_3GP) {
-        mov_write_3gp_udta_tag(pb_buf, s, "perf", "artist");
-        mov_write_3gp_udta_tag(pb_buf, s, "titl", "title");
-        mov_write_3gp_udta_tag(pb_buf, s, "auth", "author");
-        mov_write_3gp_udta_tag(pb_buf, s, "gnre", "genre");
-        mov_write_3gp_udta_tag(pb_buf, s, "dscp", "comment");
-        mov_write_3gp_udta_tag(pb_buf, s, "albm", "album");
-        mov_write_3gp_udta_tag(pb_buf, s, "cprt", "copyright");
-        mov_write_3gp_udta_tag(pb_buf, s, "yrrc", "date");
+        mov_write_3gp_udta_tag(pb_buf, s->metadata, "perf", "artist");
+        mov_write_3gp_udta_tag(pb_buf, s->metadata, "titl", "title");
+        mov_write_3gp_udta_tag(pb_buf, s->metadata, "auth", "author");
+        mov_write_3gp_udta_tag(pb_buf, s->metadata, "gnre", "genre");
+        mov_write_3gp_udta_tag(pb_buf, s->metadata, "dscp", "comment");
+        mov_write_3gp_udta_tag(pb_buf, s->metadata, "albm", "album");
+        mov_write_3gp_udta_tag(pb_buf, s->metadata, "cprt", "copyright");
+        mov_write_3gp_udta_tag(pb_buf, s->metadata, "yrrc", "date");
         mov_write_loci_tag(s, pb_buf);
     } else if (mov->mode == MODE_MOV && !(mov->flags & FF_MOV_FLAG_USE_MDTA)) { // the title field breaks gtkpod with mp4 and my suspicion is that stuff is not valid in mp4
         mov_write_string_metadata(s, pb_buf, "\251ART", "artist",      0);
diff -Naur ffmpeg-7.0.2.old/libavutil/frame.c ffmpeg-7.0.2/libavutil/frame.c
--- ffmpeg-7.0.2.old/libavutil/frame.c	2024-08-29 08:36:42.550110860 +0200
+++ ffmpeg-7.0.2/libavutil/frame.c	2024-08-29 08:36:43.652122236 +0200
@@ -934,6 +934,7 @@
     case AV_FRAME_DATA_FILM_GRAIN_PARAMS:           return "Film grain parameters";
     case AV_FRAME_DATA_DETECTION_BBOXES:            return "Bounding boxes for object detection and classification";
     case AV_FRAME_DATA_DOVI_RPU_BUFFER:             return "Dolby Vision RPU Data";
+    case AV_FRAME_DATA_DOVI_RPU_BUFFER_T35:         return "Dolby Vision RPU ITU T35 Data";
     case AV_FRAME_DATA_DOVI_METADATA:               return "Dolby Vision Metadata";
     case AV_FRAME_DATA_AMBIENT_VIEWING_ENVIRONMENT: return "Ambient viewing environment";
     }
diff -Naur ffmpeg-7.0.2.old/libavutil/frame.h ffmpeg-7.0.2/libavutil/frame.h
--- ffmpeg-7.0.2.old/libavutil/frame.h	2024-08-29 08:36:42.534110695 +0200
+++ ffmpeg-7.0.2/libavutil/frame.h	2024-08-29 08:36:43.652122236 +0200
@@ -201,6 +201,12 @@
     AV_FRAME_DATA_DOVI_RPU_BUFFER,
 
     /**
+     * Dolby Vision RPU ITU T35 raw data, suitable for passing to SVT-AV1
+     * or other libraries. Array of uint8_t.
+     */
+    AV_FRAME_DATA_DOVI_RPU_BUFFER_T35,
+
+    /**
      * Parsed Dolby Vision metadata, suitable for passing to a software
      * implementation. The payload is the AVDOVIMetadata struct defined in
      * libavutil/dovi_meta.h.
diff -Naur ffmpeg-7.0.2.old/libswscale/swscale_unscaled.c ffmpeg-7.0.2/libswscale/swscale_unscaled.c
--- ffmpeg-7.0.2.old/libswscale/swscale_unscaled.c	2024-08-29 08:36:42.412109435 +0200
+++ ffmpeg-7.0.2/libswscale/swscale_unscaled.c	2024-08-29 08:36:43.645122164 +0200
@@ -297,7 +297,7 @@
         const uint8_t *tsrc0 = src[0];
         for (x = c->srcW; x > 0; x--) {
             t = *tsrc0++;
-            output_pixel(tdstY++, t | (t << 8));
+            output_pixel(tdstY++, (t << 8));
         }
         src[0] += srcStride[0];
         dstY += dstStride[0] / 2;
@@ -308,9 +308,9 @@
             const uint8_t *tsrc2 = src[2];
             for (x = c->srcW / 2; x > 0; x--) {
                 t = *tsrc1++;
-                output_pixel(tdstUV++, t | (t << 8));
+                output_pixel(tdstUV++, (t << 8));
                 t = *tsrc2++;
-                output_pixel(tdstUV++, t | (t << 8));
+                output_pixel(tdstUV++, (t << 8));
             }
             src[1] += srcStride[1];
             src[2] += srcStride[2];
